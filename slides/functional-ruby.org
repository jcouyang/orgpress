#+TITLE: å‡½æ•°å¼ Ruby ç¼–ç¨‹
#+SUBTITLE: [[https://github.com/jcouyang][https://www.evernote.com/l/ABdT021c-5RLDp9FvGm084F6Diu-N3h-Cz8B/image.jpg]]
#+AUTHOR: [[https://oyanglul.us][æ¬§é˜³ç»§è¶…]]
#+EMAIL: oyanglulu@gmail.com
#+PROPERTY: header-args :results pp :exports both
#+OPTIONS: num:3
#+startup: beamer
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [presentation,smaller]
#+BEAMER_THEME: Madrid
#+LATEX_HEADER: \usepackage[unicode,dvipdfm]{hyperref}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \usepackage{xeCJK}
#+LATEX_HEADER: \setCJKmainfont{STXihei}
#+LATEX_HEADER: \usepackage{listings}
#+OPTIONS: num:nil
* COMMENT
#+BEGIN_SRC emacs-lisp
(require 'ox-deck)
#+END_SRC

#+RESULTS:
: ox-deck

* Agenda
- ä»€ä¹ˆæ˜¯å‡½æ•°å¼ç¼–ç¨‹
- Ruby çš„ä¸€äº›å‡½æ•°å¼ç‰¹æ€§
- ä½¿ç”¨ Monad çº¯åŒ–/ç®€åŒ–æ§åˆ¶æµ

* FBI Warning

[[./images/functional-ruby-qr.jpg]]

#+BEGIN_QUOTE
ç”¨ Nokia çš„åŒå­¦è¯·è‡ªå·±æ‰‹åŠ¨è¾“å…¥ [[https://git.io/fprb][git.io/fprb]]
#+END_QUOTE

* æˆ‘æ˜¯...
https://www.evernote.com/l/ABcPPnCpE69P3KjZoG_w5zfMmKnkmYMVeVEB/image.png

* æˆ‘æ˜¯...
https://www.evernote.com/l/ABfuI5J5AQlH1LDGI1d-DdQN1frUg3u0eYoB/image.png
[[https://gist.github.com.ru/jcouyang/6336168ecbbf4fbdc46e.png?username=jcouyang&amp;width=400&amp;height=53;.png]]

* æˆ‘è¿˜æ˜¯
[[https://img3.doubanio.com/mpic/s25996532.jpg]]
[[https://img1.doubanio.com/mpic/s28861278.jpg]]

* å•Š?
https://cloud.githubusercontent.com/assets/1235045/17973424/00e33c72-6b15-11e6-8bdf-a1a58a3631b4.jpg

#+BEGIN_QUOTE
æ‰€ä»¥æ˜¯...ä¸€ä¸ªä¼šç‚¹ Scala çš„ JavaScript ç¨‹åºå‘˜æ¥æ•™ Rubyist å‡½æ•°å¼ç¼–ç¨‹?
#+END_QUOTE

* æˆ‘åœ¨ JavaScript ç¤¾åŒºè®²å‡½æ•°å¼çš„æ—¶å€™, è§‚ä¼—æ˜¯è¿™æ ·çš„...
https://cloud.githubusercontent.com/assets/1235045/17973424/00e33c72-6b15-11e6-8bdf-a1a58a3631b4.jpg


* Ruby å‡½æ•°å¼ ?

https://cloud.githubusercontent.com/assets/1235045/17933311/321ff7d2-6a46-11e6-903e-8cc84f3acc78.JPG

#+BEGIN_QUOTE
You might be surprised to see Ruby in the list of functional languages because they generally count as object oriented languages.  
-- Martin Odersky
#+END_QUOTE

#+BEGIN_QUOTE
ä½ å¯èƒ½å¥‡æ€ªæˆ‘æŠŠRubyä¹Ÿæ”¾åˆ°äº†å‡½æ•°å¼è¯­è¨€çš„åˆ—è¡¨, è¿™äº›è¯­è¨€é€šå¸¸ä¼šè¢«å½’åˆ°é¢å‘å¯¹è±¡è¯­è¨€. 
-- Scala ä¹‹çˆ¶
#+END_QUOTE


* ä»€ä¹ˆæ˜¯å‡½æ•°å¼
https://blog.oyanglul.us/images/data-port.gif
- ä¸€ç­‰å‡½æ•° first class function / å…¥ lambda
- çº¯ purity
- å¼•ç”¨é€æ˜æ€§ referential transparency
- æ— å‰¯ä½œç”¨ side effectless
- ä¸å¯å˜ immutability
- æŒä¹…åŒ–æ•°æ®ç»“æ„ persistent data structures

...å½“çº¯åˆ°ä¸€å®šç¨‹åº¦å¯èƒ½å°±éœ€è¦
- èŒƒç•´è®º Catergory Theory

* å¥½å¤„å‘¢?

- å¥½ç»„åˆ composible
- å¥½æ¨ç† easy to reason about
- å¥½æµ‹è¯• easy to test
- å¥½å¤šçº¿ç¨‹ Multi-thread
- å¥½ç© fun
- å¥½ +é«˜é€¼æ ¼ high bigger+ elegant

* ä½ å¯èƒ½ä¸çŸ¥é“çš„Ruby
https://cloud.githubusercontent.com/assets/1235045/17936038/020c3f88-6a50-11e6-88bd-6c6ad6815495.png

* lambda aka åŒ¿åå‡½æ•°
[å¤šé€‰é¢˜] è¯·é€‰å‡ºæ‰€æœ‰çš„ lambda
#+BEGIN_SRC ruby
A: {}/do end # such as =[1,2,3].map{|x| x+1 }=
B: plus1 = lambda {|x| x + 1 }
C: plus1 = -> (x) { x + 1 }
D: plus1 = Proc.new { |x| x + 1 }
#+END_SRC

* ä¸‡ç‰©çš†å¯¹è±¡, lambda ä¹Ÿä¸ä¾‹å¤–
lambda ä¹Ÿå°±æ˜¯ä¸€ä¸ªæ­£å¸¸çš„å¯¹è±¡
#+BEGIN_SRC ruby 
plus1 = ->(x) { x + 1 }
#+END_SRC

#+RESULTS:
: #<Proc:0x007fbaea988030@-:3 (lambda)>

* å¦‚æœç»™è¿™ä¸ªlambdaä¸€ä¸ªå¼•ç”¨,æˆ‘ä»¬å¯ä»¥è·Ÿç”¨methodä¸€æ ·ç”¨
#+BEGIN_SRC ruby 
  plus1 = ->(x) { x + 1 }
  plus1.call(3)
  plus1.(3)
  plus1[3]
#+END_SRC

#+RESULTS:
: 4

* ä¸‰ç­‰å…¬æ°‘
#+BEGIN_SRC ruby  :results pp
  def plus1 x
    x + 1
  end
  [1,2,3,4].map &plus1
#+END_SRC

: `plus1': wrong number of arguments (0 for 1) (ArgumentError)

* ä¸€ç­‰ vs ä¸‰ç­‰
https://www.evernote.com/l/ABcXHBGTERhJv5sNDPdAeiseZP0ke-Pd9TYB/image.png

* ä¸€ç­‰å…¬æ°‘ Proc
#+BEGIN_SRC ruby  :results pp
plus1 = ->(x) { x + 1 }
[1,2,3,4].map &plus1
#+END_SRC

#+RESULTS:
: [2, 3, 4, 5]

* ç»™ä¸‰ç­‰åº§å‡ä¸ªèˆ±
#+BEGIN_SRC ruby  :results pp
  def plus1 x
    x + 1
  end
  first_class_plus1 = method(:plus1)
  [1,2,3,4].map &first_class_plus1
#+END_SRC

#+RESULTS:
: [2, 3, 4, 5]

* å‡èˆ±çš„é­”æ³• =#to_proc=
#+BEGIN_SRC ruby
method(:plus1)
# => #<Method: Object#plus1>
#+END_SRC

#+BEGIN_SRC ruby
  class Method
    def to_proc
      lambda{|*args|
        self.call(*args)
      }
    end
  end
#+END_SRC

* å‡èˆ±å®ä¾‹2 - Symbol
#+BEGIN_SRC ruby  :results pp
  %w(ouyang jichao).map &:capitalize 
  # ===
  %w(ouyang jichao).map { |x| x.capitalize}
#+END_SRC

#+RESULTS:
: ["Ouyang", "Jichao"]

* æ¥ ğŸ¬ Desugar =&=

#+BEGIN_SRC ruby
  %w(ouyang jichao).map &:capitalize.to_proc
#+END_SRC

#+BEGIN_SRC ruby
  %w(ouyang jichao).map &Proc.new(|x| x.send(:capitalize))
#+END_SRC

#+RESULTS:
: ["Ouyang", "Jichao"]

* æ¨¡å¼åŒ¹é… pattern matching
https://i.giphy.com/3o6MbdPcxvF7Hb5G3S.gif

* destructure - æ•°ç»„
#+BEGIN_SRC ruby :results pp
first, *middle_and_last = ['Phillip', 'Jay', 'Fry']
"first: #{first}, middle_and_last: #{middle_and_last}"
#+END_SRC

#+RESULTS:
: "first: Phillip, middle_and_last: [\"Jay\", \"Fry\"]"

* destructure - å“ˆå¸Œ
æ–¹æ³•çš„å‚æ•°ä¼šè‡ªå¸¦ destructure å“ˆå¸Œçš„åŠŸèƒ½ aka =keyword arguments=:
#+BEGIN_SRC ruby :results pp
  fry = {first: 'Phillip', middle: 'Jay', last: 'Fry'}
  def printFirstName first:, **rest
    p first, rest
  end
  printFirstName fry
#+END_SRC

#+RESULTS:
: ["Phillip", {:middle=>"Jay", :last=>"Fry"}]

* case when
ruby ä¸­çš„ case å¯ä»¥æå®šè¿™å‡ ç§æ¨¡å¼åŒ¹é…
- å€¼/è¡¨è¾¾å¼
- ç±»å‹
- Proc
- æ­£åˆ™

* å€¼
è¿™ä¸ªå¾ˆç®€å•ï¼Œåº”è¯¥éƒ½æœ‰ç”¨è¿‡
#+BEGIN_SRC ruby
  me = 'ouyang'
  case me
  when 'ouyang' 
    "hehe #{me}"
  else 'hehe jichao'
  end
#+END_SRC

#+RESULTS:
: hehe ouyang

* ç±»å‹
#+BEGIN_SRC ruby
  class Me
    def initialize name
      @name = name
    end

    def heheda
      "å‘µå‘µå“’ #{@name}"
    end
  end

  me = Me.new 'ouyang'

  case me
  when Me
    me.heheda
  else
    'å‘µå‘µå“’äº†'
  end
#+END_SRC

* lambda ï¼ˆaka guardï¼‰
#+BEGIN_SRC ruby
  require 'ostruct'
  me = OpenStruct.new(name: 'jichao', first_name: 'ouyang')
  case me
  when ->(who){who.name=='jichao'}
    "hehe #{me}"
  end
#+END_SRC

#+RESULTS:
: hehe #<OpenStruct name="jichao", first_name="ouyang">

* /æ­£åˆ™/
#+BEGIN_SRC ruby
case 'jichao ouyang'
when /ouyang/
"å‘µå‘µå“’"
end
#+END_SRC

#+RESULTS:
: "å‘µå‘µå“’"

* ä½†å…¶å®åªæ˜¯ä¸ªç®€å•çš„è¯­æ³•ç³–
case when å¹¶ä¸æ˜¯magicï¼Œå…¶å®åªæ˜¯ if else çš„è¯­æ³•ç³–, æ¯”å¦‚ä¸Šé¢è¯´çš„æ­£åˆ™
#+BEGIN_SRC ruby
  if(/ouyang/ === 'jichao')
    "heheda"
  end
#+END_SRC

æ‰€ä»¥ magic åˆ™æ˜¯æ‰€æœ‰ when çš„å¯¹è±¡éƒ½å®ç°äº† ~===~ æ–¹æ³•è€Œå·²
- å€¼ï¼š ~object.===~ ä¼šä»£ç†åˆ° ~==~
- ç±»å‹ï¼š ~Module.===~ ä¼šçœ‹æ˜¯å¦æ˜¯å…¶ instance
- æ­£åˆ™ï¼š ~regex.===~ å¦‚æœåŒ¹é…è¿”å› true
- è¡¨è¾¾å¼ï¼šå–å†³äºè¡¨è¾¾å¼è¿”å›çš„å€¼çš„ ~===~ æ–¹æ³•
- lambdaï¼š ~proc.===~ ä¼šè¿è¡Œ lambda æˆ–è€… proc

* 
https://i.giphy.com/55xWvUIMb51mw.gif
#+BEGIN_QUOTE
è¯´äº†è¿™ä¹ˆäº›å¥‡æŠ€æ·«å·§, +é€¼æ ¼è¿˜æ˜¯ä¸å¤Ÿé«˜å‘€+ é™¤äº†èŠ±å¼ä¸€äº›æœ‰ä»€ä¹ˆç”¨å‘¢?
#+END_QUOTE

#+BEGIN_QUOTE
çº¯ pure
#+END_QUOTE

* Category Theory
#+BEGIN_QUOTE
Monad - è‡ªå‡½å­èŒƒç•´ä¸Šçš„å«å¹ºåŠç¾¤
#+END_QUOTE

* ä¸€ä¸ªç®€å• ğŸŒ°
#+BEGIN_QUOTE
æŠŠå¤§è±¡æ”¾å†°ç®±é‡Œéœ€è¦å‡ æ­¥
#+END_QUOTE
https://www.evernote.com/l/ABeEwMnpRdVB7pup8Sw-KV3Iq02sI7fSe90B/image.png

* å‘½ä»¤å¼æ”¾å¤§è±¡
#+BEGIN_SRC ruby
  opened_fridge = open_fridge
  if opened_fridge
    fridge_w_elephent = put_elephent_in opened_fridge
    if fridge_w_elephent
      closed_fridge = close_fridge
      if closed_fridge
        'yay'
      else
        'fail to close fridge'
      end
    else
      'fail to put elephent in'
    end
  else
    'fail to open fridge'
  end
#+END_SRC

* ç›‘æ§
#+BEGIN_SRC ruby
  opened_fridge = open_fridge
  if opened_fridge
    Monitoring.logger.info('fridge opened')
    fridge_w_elephent = put_elephent_in opened_fridge
    if fridge_w_elephent
      Monitoring.logger.info('puted a elephent into fridge')
      closed_fridge = close_fridge
      if closed_fridge
        Monitoring.logger.info('fridge closed')
        'yay'
      else
        Monitoring.logger.error('no able to close fridge')
        'fail to close fridge'
      end
    else
      Monitoring.logger.error('elephent put failed')
      'fail to put elephent in'
    end
  else
    Monitoring.logger.error('fail to open fridge')
    'fail to open fridge'
  end
#+END_SRC

* æˆ–è€…ç”¨æ›´æç«¯çš„æŠ›å¼‚å¸¸æ–¹å¼
#+BEGIN_SRC ruby
  begin
    close(put_elephent_in open_fridge)
  rescue A=>e
   ...
  rescue B=>e
   ...
  rescue C=>e
   ...
  end
#+END_SRC

* å¹¿å‘Šæ—¶é—´

#+BEGIN_EXAMPLE
ğŸ˜¹ â¡ï¸ ğŸ˜¼
â¬‡ï¸ â†˜ï¸ â¬‡ï¸
ğŸ™€ â¡ï¸ ğŸ˜»
#+END_EXAMPLE
#+BEGIN_QUOTE
çŒ«å‘¢?

https://git.io/cats.rb
#+END_QUOTE

* è®©æˆ‘ä»¬ç”¨ä¸€ä¸ªç®€å•çš„ [[https://github.com/jcouyang/cats.rb#dataeither][Either Monad]]
#+BEGIN_EXAMPLE
gem install data.either
#+END_EXAMPLE

#+BEGIN_SRC ruby :eval no
require 'data.either'
Right.new(1).flat_map do |x| 
  if x < 1
    Left.new('meh')
  else
    Right.new(x+1)
  end
end
# => #<Right 2>
#+END_SRC

* æ¥ç®€åŒ–æ§åˆ¶æµ
#+BEGIN_SRC ruby :eval no
  open_fridge.flat_map do |fridge|  # <= 1
    put_elephent_in fridge          # <= 2
  end.flat_map do |fridge|
    close fridge                    # <= 3
  end
#+END_SRC

è¿™æ ·å¯ä»¥ä¸“å¿ƒæ„é€ æ§åˆ¶é€»è¾‘,è€Œä¸éœ€è¦å…³å¿ƒä¸Šä¸€æ­¥å¦‚æœé”™è¯¯è¯¥æ€ä¹ˆåŠ

* æ€ä¹ˆåšåˆ°çš„
https://i.giphy.com/12dBjCf9NclhBe.gif

* 
https://www.evernote.com/l/ABfo-EYfrKlJ9L8jv7jh_927W-0Z3h7_FZsB/image.png

* Either é­”æ³•
#+caption: https://github.com/jcouyang/cats.rb/blob/master/lib/data.either.rb
#+BEGIN_SRC ruby :eval no
  def flat_map
    case self
    when Right
      yield @v
    else
      self
    end
  end
#+END_SRC

* ä¸€ä¸ªæ›´å®é™…çš„ ğŸŒ°
ç”¨ microservices ç»„åˆæˆæ–°çš„ service

https://www.evernote.com/l/ABd47442ZCNJHbYn1sfcZhZtV2jFjftPdRwB/image.png

* ä¸Šå›¾æœ‰å‡ æ¬¡ IO
- æ€»å…±4ä¸ªIO, æ¯ä¸€æ­¥éª¤éƒ½å¯èƒ½å‡ºé”™
- ä½†ç¨‹åºçŒ¿ä¸å¸Œæœ›æ¼æ‰ä»»ä½•é”™è¯¯ä¿¡æ¯
- ä½†æ˜¯åˆä¸èƒ½ä¸ºäº†ç›‘æ§,å½±å“äº†è¿™ä¸ªç®€å•çš„å·¥ä½œæµ

* æ§åˆ¶æµä¸å…³å¿ƒå¤±è´¥å’Œç›‘æ§
#+BEGIN_SRC haskell
  do
    a <- fetchA
    b <- fetchB
    c <- put $ blah a ++ b
#+END_SRC

* IOè‡ªæŒ‚ä¸œå—æ
https://www.evernote.com/l/ABeIbzxUeghNkZMGpgZljl8K0P6JNasFga4B/image.jpg

* 
#+BEGIN_SRC ruby :eval no
  def fetch(endpoint, decoder)
    response = self.class.get(endpoint, format: :json)
    case response.code
    when 410
      Left.new(Exceptions::DataFailure.new("Resource #{endpoint} was deleted"))
    when 404
      Left.new(Exceptions::DataFailure.new("Resource #{endpoint} not exist"))
    when 200
      Right.new decoder.from_json(response.body)
    else
      Left.new(Exceptions::RepositoryError.new("Fetching #{endpoint} with Error:\n#{endpoint}, response code: #{response.code}"))
    end
  end
#+END_SRC

* 
#+BEGIN_SRC ruby :eval no
  failure_processed, success_processed = Either.partition Mapinator.run

  Monitoring.send_processed success_processed.length
  Monitoring.logger.info("Processed successful #{success_processed.length} listings: #{success_processed}")
  Monitoring.logger.error("Processed FAILURE #{failure_processed.length} with Exceptions:") unless failure_processed.empty?
  ...
#+END_SRC

* è¿˜å¯ä¸å¯ä»¥åœ¨çº¯ä¸€äº›
https://imgs.xkcd.com/comics/haskell.png

* Free Monad aka Interpreter Pattern
https://www.evernote.com/l/ABe66Nse7nlPpKWTYgGPBFWt1Uv_m-ZFn_cB/image.png

* æœ‰äº›åƒ Cons
https://www.evernote.com/l/ABecKErC7s5Mpa6cfyAt3mL7zpTS9v1N85QB/image.png

* è¿˜æœ‰...
- Coyoneda
- Free Monoid
- State
- EitherT
- MaybeT
- ...

* 
#+BEGIN_QUOTE
è¿™äº›æˆ‘éƒ½ä¸ä¼šè®²...
#+END_QUOTE


* 
#+BEGIN_QUOTE
å› ä¸ºæˆ‘ä¸ä¼šè®²...
#+END_QUOTE

å¸Œæœ›ä¸ä¹…ä¹‹åå¯ä»¥... 
#+BEGIN_EXAMPLE
gem install control.monad.free
#+END_EXAMPLE

* Q/A

* æ€§èƒ½
https://www.evernote.com/l/ABdxEUHAmZlMII8QBKAYYtI5xgY4KkO1T7MB/image.png
#+BEGIN_QUOTE
ä½ TMéƒ½é€‰ Ruby äº†è¿˜åœ¨ä¹æ€§èƒ½?
#+END_QUOTE

* å¹¶å‘å¤šçº¿ç¨‹ made easy
#+BEGIN_SRC ruby :eval no
require "celluloid/autostart"

module Enumerable
  def pmap(&block)
    futures = map { |elem| Celluloid::Future.new(elem, &block) }
    futures.map(&:value)
  end
end
#+END_SRC

* å¤šè°¢
- https://blog.oyanglul.us/functional-ruby.html
- https://github.com/jcouyang/cats.rb
- https://github.com/typelevel/cats
- http://hackage.haskell.org/package/base-4.8.1.0/docs/src/Data.Either.html
- https://wiki.haskell.org/Free_structure
- http://underscore.io/blog/posts/2015/04/23/deriving-the-free-monad.html
- http://underscore.io/blog/posts/2015/04/14/free-monads-are-simple.html
- https://www.coursera.org/learn/progfun2
- https://www.amazon.com/Well-Grounded-Rubyist-David-Black/dp/1933988657
- https://mitpress.mit.edu/sicp
