<!DOCTYPE html>
<html>
<head>
<!-- 2015-08-14 Fri 13:32 -->
<meta  charset="utf-8">
<meta  name="viewport" content="width=device-width, initial-scale=1">
<title>自制语言初试 - 入lang</title>
<meta  name="generator" content="Org-mode">
<meta  name="author" content="Jichao Ouyang">
<meta  name="keywords" content="macro, javascript, clojure, lisp, sweetjs, meta programming">
<link rel="apple-touch-icon" sizes="57x57" href="/assets/apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="/assets/apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="/assets/apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="/assets/apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="/assets/apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="/assets/apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="/assets/apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="/assets/apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-icon-180x180.png">
<link rel="icon" type="image/png" sizes="192x192"  href="/assets/android-icon-192x192.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="/assets/favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
<link rel="manifest" href="/assets/manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="/assets/ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/pixyll.css"/>
<link rel="alternate" type="application/rss+xml" title="Jichao Ouyang" href="http://blog.oyanglul.us/index.xml"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="/index.html"> UP </a>
 |
 <a accesskey="H" href="/~jichao.ouyang.html"> HOME </a>
</div><div id="content">
<header>
<h1 class="title">自制语言初试 - 入lang</h1>
</header><nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">Rationale(为毛要整一门语言)</a>
<ul>
<li><a href="#orgheadline2">ClojureScript怎么就不好了</a></li>
<li><a href="#orgheadline3">ClojureScript的数据结构移植</a></li>
<li><a href="#orgheadline4">那macro呢</a></li>
</ul>
</li>
<li><a href="#orgheadline5">Ru-lang, The First Attampt</a>
<ul>
<li><a href="#orgheadline6">lambda</a></li>
<li><a href="#orgheadline7">Let</a>
<ul>
<li><a href="#orgheadline8">block scope binding</a></li>
<li><a href="#orgheadline9">destruture array</a></li>
<li><a href="#orgheadline10">looprecur</a></li>
</ul>
</li>
<li><a href="#orgheadline11">Existential ?</a>
<ul>
<li><a href="#orgheadline12">Infix macro</a></li>
</ul>
</li>
<li><a href="#orgheadline13">在哪里才能买到呢</a></li>
</ul>
</li>
</ul>
</div>
</nav>
<a aria-label="Star jcouyang/ru on GitHub" data-count-aria-label="# stargazers on GitHub" data-count-api="/repos/jcouyang/ru#stargazers_count" data-count-href="/jcouyang/ru/stargazers" data-style="mega" data-icon="octicon-star" href="https://github.com/jcouyang/ru" class="github-button">Star</a>

<a href="https://news.ycombinator.com/submit" class="hn-button" data-url="http://ru-lang.org" data-count="horizontal">Vote on Hacker News</a><script type="text/javascript">var HN=[];HN.factory=function(e){return function(){HN.push([e].concat(Array.prototype.slice.call(arguments,0)))};},HN.on=HN.factory("on"),HN.once=HN.factory("once"),HN.off=HN.factory("off"),HN.emit=HN.factory("emit"),HN.load=function(){var e="hn-button.js";if(document.getElementById(e))return;var t=document.createElement("script");t.id=e,t.src="//hn-button.herokuapp.com/hn-button.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n)},HN.load();</script>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">Rationale(为毛要整一门语言)</h2>
<div class="outline-text-2" id="text-orgheadline1">

<figure>
<p><img src="./images/tv-giving-me-reason-to-live.gif" alt="tv-giving-me-reason-to-live.gif">
</p>
</figure>
</div>

<div id="outline-container-orgheadline2" class="outline-3">
<h3 id="orgheadline2">ClojureScript怎么就不好了</h3>
<div class="outline-text-3" id="text-orgheadline2">
<p>
接上篇简单的介绍sweet.js之后, 萌发了特别crazy的idea. 如果CoffeeScript或者LiveScript也算
语言的话, 其实单单用sweet.js自制一堆macro就能实现类似的语言. 当然, 这两门语言都比较奇特, 一个
像似ruby和python的熊孩子, 另一个是F#和coffee的熊孩子, 总之, 没有一门是符合我自己的编程习惯.
</p>

<p>
而如果用Clojure写前端也就是用ClojureScript的话, 由于是完全另一门语言, 跟JS其他库交互会非常麻烦. 而像Coffee则没有
这个问题, 难道就不能有一种ClojureScript可以完全兼容JavaScript, 又可以用到Clojure的各种
奇特函数呢.
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3">ClojureScript的数据结构移植</h3>
<div class="outline-text-3" id="text-orgheadline3">
<p>
ClojureScript的作者David做了一个非常有意思的项目,把ClojureScript的数据结构单独导出来做成类似underscore的库 - <a href="https://github.com/swannodette/mori">mori</a>.
官方的解释是
</p>
<blockquote>
<p>
A simple bridge to ClojureScript's persistent data structures and supporting APIs for vanilla JavaScrip
</p>
</blockquote>
<p>
恩, 这不正是我想要的吗. 可以直接在JavaScript中使用ClojureScript的数据结构.
</p>

<p>
但是&#x2026;
</p>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">那macro呢</h3>
<div class="outline-text-3" id="text-orgheadline4">
<p>
David导出了所有的数据结构以及function, 但是像macro却不可能直接导成JavaScript, 因为是编译时
扩展的.
</p>

<p>
但是macro却是clojure(或者lisp语言)最吸引人的地方之一. 如果能移植过来讲会开启在用原生JS中使用到
所有ClojureScript features的无限可能. 比如就可以把 <a href="./clojure-core.async-essence-in-native-javascript.html">core.async</a> 移植过来.
</p>

<p>
于是为了验证移植macro的可能性, 我用Sweet.js实现了部分macro或者clojure的keyword, 我把这些
macros和mori的集合叫 <a href="http://ru-lang.org/">ru-lang</a> , 这样就可以用类似JavaScript的形式, 使用到所有Clojure的好处.
</p>

<blockquote>
<p>
Hacker News 上的讨论 <a href="https://news.ycombinator.com/item?id=9749286">https://news.ycombinator.com/item?id=9749286</a>
</p>
</blockquote>
</div>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5">Ru-lang, The First Attampt</h2>
<div class="outline-text-2" id="text-orgheadline5">
<p>
叫做  <a href="http://ru-lang.org/">ru-lang</a> 有两层意思
</p>
<ul class="org-ul">
<li>"入"长得像 &lambda; 的汉字, 所以 "入-lang" 也长得像 Clojure 的 JavaScript</li>
<li>"入" 表示一些东西新加入JavaScript</li>
</ul>
</div>

<div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6">lambda</h3>
<div class="outline-text-3" id="text-orgheadline6">
<p>
Clojure有一个很cool的macro, <code>#{}</code>, 匿名函数的macro, cool的地方是它可以用 <code>%1</code>, <code>%2</code>
代表第几个参数. 特别方便比如是在用map的时候
</p>
<div class="org-src-container">

<pre class="src src-clojure">(map #(<span style="color: #b8860b;">%</span>+3) [1,2,3,4])
</pre>
</div>

<p>
移植这个macro还是比较简单的, 虽然真正的 <code>#</code> 在clojure中是一个切换reader table的标志, 可能
要更复杂一下, 但是这里我们只是想要一个简单的带place holder的匿名函数.
</p>

<p>
由于#算是sweetjs的保留字符, 我把 <code>#</code> 换成 <code>fn</code> 来代替, <code>%</code> 在js里又是运算符, 改用 <code>$</code> 代替, 
那么ru-lang版的匿名函数就变成了
</p>
<div class="org-src-container">

<pre class="src src-javascript">map(fn($+3), [1,2,3,4])
</pre>
</div>

<p>
很像clojure对不对, 但是又还是保留了js的语法, 是不是有点感觉怪怪的东西悄悄乱入了
</p>

<p>
实现的思路则非常简单, 使用 <a href="./clojure-essence-in-javascript-macro.html">上篇</a> 提到的 Case macro
</p>
<ol class="org-ol">
<li>把 <code>fn</code> 的参数里面所有的 <code>$n</code> token 找到</li>
<li>把所有token的 <code>$n</code> 变成 <code>arguments[n]</code></li>
<li>用js的匿名函数包上, 返回</li>
</ol>

<div class="org-src-container">

<pre class="src src-javascript">macro fn {
<span style="color: #00008b;">case</span> {
  $ctx
  ($body:expr)
}=&gt;{
  <span style="color: #00008b;">function</span> <span style="color: #6a5acd;">replace_args</span>(<span style="color: #b8860b;">stxs</span>){
    <span style="color: #00008b;">return</span> stxs.map(<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">x</span>){
      <span style="color: #00008b;">if</span>(x.token.inner) {x.token.inner = replace_args(x.token.inner); <span style="color: #00008b;">return</span> x}
      <span style="color: #00008b;">if</span>(x.token.type==parser.Token.Identifier &amp;&amp; x.token.value.match(<span style="color: #8b0000;">/^\$(\d?)$/</span>)){
        <span style="color: #00008b;">var</span> <span style="color: #b8860b;">num</span> = x.token.value.match(<span style="color: #8b0000;">/^\$(\d?)$/</span>).pop()
        <span style="color: #00008b;">if</span>(!num) num=1;
        <span style="color: #00008b;">return</span> makeIdent(<span style="color: #8b0000;">'arguments['</span>+(num-1)+<span style="color: #8b0000;">']'</span>,#{$body});
      }
      <span style="color: #00008b;">return</span> x;
    })
  }
  <span style="color: #00008b;">var</span> <span style="color: #b8860b;">body</span> = replace_args(#{$body})
  letstx $new_body = body
  <span style="color: #00008b;">return</span> #{
    (<span style="color: #00008b;">function</span>(){<span style="color: #00008b;">return</span> $new_body})}
}
}

<span style="color: #00008b;">export</span> fn;
</pre>
</div>

<p>
注意 <code>replace_args</code> 是递归的去替换所有token以及token的inner token
</p>

<p>
这个太简单了,来个难点的macro吧
</p>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7">Let</h3>
<div class="outline-text-3" id="text-orgheadline7">
<p>
let 怎么就难了&#x2026;
</p>

<p>
当然, clojure的let功能很多的
</p>
<ul class="org-ul">
<li>block scope binding</li>
<li>如果是array或者map, 还能destructure</li>
<li>如果是递归的let, 就变成了looprecur</li>
</ul>

<p>
因此我们要实现let需要实现4个东西
</p>
<ul class="org-ul">
<li>block scope binding</li>
<li>destruture array</li>
<li>destructure map</li>
<li>looprecur</li>
</ul>

<p>
我们一样一样来
</p>
</div>

<div id="outline-container-orgheadline8" class="outline-4">
<h4 id="orgheadline8">block scope binding</h4>
<div class="outline-text-4" id="text-orgheadline8">
<p>
我们都知道js var是function scope, 也就是说可以
</p>
<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #00008b;">var</span> <span style="color: #b8860b;">a</span> =1;
<span style="color: #00008b;">for</span>(<span style="color: #00008b;">var</span> <span style="color: #b8860b;">a</span>=0;a&lt;3;a++){
  <span style="color: #00008b;">var</span> <span style="color: #b8860b;">b</span> = a+1
}
console.log(a, b)<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">=&gt; 3,3</span>
</pre>
</div>

<p>
所有的var会被hoist到函数的顶部, 相当于
</p>
<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #00008b;">var</span> <span style="color: #b8860b;">a</span>,<span style="color: #b8860b;">b</span>;
a=1
  <span style="color: #00008b;">for</span>(a=0;a&lt;3;a++){
    b = a+1
  }
</pre>
</div>

<p>
虽然 <a href="./essential-ecmascript6.html">es6 支持了 let block scope</a> 局部变量的定义, 但还是没有类似clojure的 let 表达式
</p>

<p>
我喜欢能有这样一个东西
</p>

<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #00008b;">let</span>(a=1,b=2){a+b} === 3
</pre>
</div>

<p>
由于js只有function scope, 所以应该要扩展成
</p>
<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #00008b;">function</span>(<span style="color: #b8860b;">a</span>,<span style="color: #b8860b;">b</span>){
  <span style="color: #00008b;">return</span> a+b
}(1,2)
</pre>
</div>


<p>
用macro实现这个再简单不过了
</p>
<div class="org-src-container">

<pre class="src src-javascript">macro <span style="color: #00008b;">let</span> {
  rule { ($($key:ident=$val:expr) (,)...){$body:expr...$last:expr} } =&gt;{
    (<span style="color: #00008b;">function</span>(<span style="color: #b8860b;">$key</span>(,)...){
      $body...
        <span style="color: #00008b;">return</span> $last
    })($val(,)...)
  }
}
</pre>
</div>

<p>
so easy, <del>block scope binding</del>
</p>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-4">
<h4 id="orgheadline9">destruture array</h4>
<div class="outline-text-4" id="text-orgheadline9">
<p>
这个就稍微有那么点难度, 我们先把它分解成小问题
</p>
<ol class="org-ol">
<li>一个空的binding返回空</li>
</ol>
<div class="org-src-container">

<pre class="src src-javascript">[]=[1,2,3] -&gt; nothing
</pre>
</div>
<ol class="org-ol">
<li>一个正常的binding还是它自己</li>
</ol>
<div class="org-src-container">

<pre class="src src-javascript">a=[1,2,3] -&gt; a=[1,2,3]
</pre>
</div>
<ol class="org-ol">
<li>单个元素的destruct, 等于第一个元素</li>
</ol>
<div class="org-src-container">

<pre class="src src-javascript">[a] = [1,2,3] -&gt; a=[1,2,3][0]
</pre>
</div>
<ol class="org-ol">
<li>多个元素的destruct, 等于用第4部destruct头元素, 用5递归destruct尾部元素</li>
</ol>
<div class="org-src-container">

<pre class="src src-javascript">[a,b,c] = [1,2,3] -&gt; destruct2(a=1), destruct5([,b,c]=[,2,3])
</pre>
</div>
<ol class="org-ol">
<li>尾部的destruct, 同样取第一个元素destruct, 然后自递归</li>
</ol>
<div class="org-src-container">

<pre class="src src-javascript">[,b,c] = [,2,3] -&gt; destruct2(b=2), destruct5([,c]=[,3])
</pre>
</div>
<ol class="org-ol">
<li>最后一个元素的destruct</li>
</ol>
<div class="org-src-container">

<pre class="src src-javascript">[,c] =[,3] -&gt; c=3
</pre>
</div>

<p>
phewww&#x2026;&#x2026;分解完好像覆盖了所有情况了, 现在用macro实现就太简单了
</p>
<div class="org-src-container">

<pre class="src src-javascript">macro destruct {
  <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">1</span>
  rule {[]=$val:expr} =&gt; {}
  <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">2</span>
  rule {$id:ident=$val:expr} =&gt; {$id=($val)}
  <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">3</span>
  rule {[$id:ident]=$val:expr} =&gt; { $id=($val[0]) }
  <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">6</span>
  rule { [,$last:ident]=$val:expr}=&gt;{$last=($val[0])}
  <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">5</span>
  rule {[, $id:ident $tail...]=$val:expr}=&gt; {destruct $id=($val.shift()), destruct [$tail...]=$val.slice(1)}
  <span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">4</span>
  rule {[$id:ident $tail...]=$val:expr} =&gt; {destruct $id=($val.shift()), destruct [$tail...]=$val.slice(1)}
}
</pre>
</div>

<p>
完了吗? 好像还没有, 万一有嵌套呢, 比如这样
</p>
<div class="org-src-container">

<pre class="src src-javascript">[a, [b,c]] =[1,[2,3],4]
</pre>
</div>

<p>
好吧, 不就是再多一层递归么, 拨开便好了
</p>
<div class="org-src-container">

<pre class="src src-javascript"><span style="color: #8c8c8c; font-style: italic;">//</span><span style="color: #8c8c8c; font-style: italic;">&#22836;&#37096;&#23884;&#22871;, &#25320;&#24320;</span>
rule {[[$id:ident]]=$val:expr} =&gt; { destruct [$id]=($val[0]) }
<span style="color: #8c8c8c; font-style: italic;">// </span><span style="color: #8c8c8c; font-style: italic;">&#23614;&#37096;&#23884;&#22871;, &#25320;&#24320;&#25320;&#24320;</span>
rule { [,[$last:ident]]=$val:expr}=&gt;{destruct [$last]=($val[0])}
</pre>
</div>

<p>
destructure object 的过程也非常类似, 我就懒得实现了
</p>
</div>
</div>
<div id="outline-container-orgheadline10" class="outline-4">
<h4 id="orgheadline10">looprecur</h4>
<div class="outline-text-4" id="text-orgheadline10">
<p>
looprecur其实就是let的尾递归, 很容易变成循环
</p>
<div class="org-src-container">

<pre class="src src-javascript">loop(a=1,b=18){
  <span style="color: #00008b;">if</span> (a &gt; b)
    <span style="color: #00008b;">return</span> a
  recur (a++,b--)
}
</pre>
</div>
<p>
其实就是特殊的let, 只是在尾部从新绑定了 a 和 b 的值, 然后在let一下, 虽然是 clojure的东东, 但是这里
是不是看起来非常的像JS原生呢:)
</p>

<p>
好了, 我们期待的当然是直接优化成循环了
</p>
<div class="org-src-container">

<pre class="src src-javascript">(fucntion (a,b) {
  <span style="color: #00008b;">while</span>(<span style="color: #6b8e23;">true</span>){
    <span style="color: #00008b;">if</span>(a&gt;b)
      <span style="color: #00008b;">return</span> a
    a++;
    b--;
  }
})(1,18)
</pre>
</div>

<p>
let都实现了, 实现这也太容易了
</p>
<div class="org-src-container">

<pre class="src src-javascript">macro loop {
  rule {($params...){$body... recur($binding:expr(,)...)}} =&gt; {
    <span style="color: #00008b;">let</span>($params...){
      <span style="color: #00008b;">while</span> (<span style="color: #6b8e23;">true</span>) {
        $body...;
          $binding(;)...
      }
    }
  }
}
</pre>
</div>
<p>
直接调用let就好了, 只要把body循环那么一下, binding放到循环最后.
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11">Existential ?</h3>
<div class="outline-text-3" id="text-orgheadline11">
<p>
只移植 clojure 是不是开始有点无聊了, 让我们换换口味. CoffeeScript的判空我一直是非常喜欢, 不如试试也移过来,就可以这样了.
</p>
<div class="org-src-container">

<pre class="src src-javascript">a?.b?().c?=1
</pre>
</div>

<p>
比起嵌套一大堆if else或者是 Haskell fancy的 maybe monad, 这样的判空操作非常简单而且可读.
</p>


<figure>
<p><img src="./images/maybe.gif" alt="maybe.gif">
</p>
</figure>
</div>

<div id="outline-container-orgheadline12" class="outline-4">
<h4 id="orgheadline12">Infix macro</h4>
<div class="outline-text-4" id="text-orgheadline12">
<p>
还记得 <a href="./clojure-essence-in-javascript-macro.html">上篇</a> 提到这次要讲 Infix macro吗, 恩, 要实现 <code>?</code> 我们必不可少需要使用Infix macro.
</p>

<p>
等等, 什么是 Infix macro.
</p>

<p>
注意前面一堆 macro 的keyword都是在开始的, 比如 let, loop, 都必须以这个关键字开始, macro才知道怎么去扩展.
</p>

<p>
那么问题来了, <code>?</code> 其实是中间的关键字, 我们需要拿到 <code>?</code> 前和 <code>?</code> 后的 token. 这正是 infix macro 能干的事情.
</p>

<p>
来思考一下如果拿到 <code>?</code> 前后的 token 我们应该要怎么办? 当然是写成 if 判断咯, <code>?</code> 前面的是判断对象, 如果为true
则与后面的token连上(把 <code>?</code> 去掉)
</p>

<div class="org-src-container">

<pre class="src src-javascript">macro (?) {
  rule infix {$left:expr | $right... } =&gt; {
    (<span style="color: #00008b;">function</span>(){
      <span style="color: #00008b;">if</span>(<span style="color: #00008b;">typeof</span> $left!==<span style="color: #8b0000;">'undefined'</span> &amp;&amp; $left!==<span style="color: #6b8e23;">null</span>){
        <span style="color: #00008b;">return</span> $left $right...
      }
    })()
  }
}
</pre>
</div>

<p>
注意 infix macro 需要在 rule 后加上 <code>infix</code> 的keyword. 当然 infix 不仅可以用于 rule macro, 同样也可以用到
case macro
</p>
<div class="org-src-container">

<pre class="src src-javascript">macro (?) {
  <span style="color: #00008b;">case</span> infix {$left:expr |$name $right... } =&gt; {
    <span style="color: #00008b;">return</span> #{
      (<span style="color: #00008b;">function</span>(){
        <span style="color: #00008b;">if</span>(<span style="color: #00008b;">typeof</span> $left!==<span style="color: #8b0000;">'undefined'</span> &amp;&amp; $left!==<span style="color: #6b8e23;">null</span>){
          <span style="color: #00008b;">return</span> $left $right...
        }
      })()  
    }
  }
}
</pre>
</div>

<p>
稍微不一样的是原来case macro的第一个参数要放到 <code>|</code> 后面了
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13">在哪里才能买到呢</h3>
<div class="outline-text-3" id="text-orgheadline13">

<figure>
<p><img src="./images/shut-up-and-take-my-money.gif" alt="shut-up-and-take-my-money.gif">
</p>
</figure>

<p>
总之第一次尝试用 sweet.js移植一些macro 或者其他语言的语法糖看似还不错, ru-lang 还在 heavy development 阶段, 虽然
还不完整, 但是总算可以证实这个想法的可行性, 接下来一块很难啃的骨头应该是移植 core.async.
</p>

<p>
另外 <a href="./clojure-essence-in-javascript-macro.html">上篇</a> 提到的还说要解释operator, 这里就懒得说了, 如果把 infix macro 的前后都改成 expr, 其实是差不多的,
只是operator 还会多两个东西, 优先级, 左结合还是有结合. 当然用法跟 infix macro是非常像的, 我就不多说了.
</p>

<p>
如果对这个项目有兴趣, 不妨接着在hacker news
</p>
<a href="https://news.ycombinator.com/submit" class="hn-button" data-url="http://ru-lang.org" data-count="horizontal">Vote on Hacker News</a><script type="text/javascript">var HN=[];HN.factory=function(e){return function(){HN.push([e].concat(Array.prototype.slice.call(arguments,0)))};},HN.on=HN.factory("on"),HN.once=HN.factory("once"),HN.off=HN.factory("off"),HN.emit=HN.factory("emit"),HN.load=function(){var e="hn-button.js";if(document.getElementById(e))return;var t=document.createElement("script");t.id=e,t.src="//hn-button.herokuapp.com/hn-button.js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(t,n)},HN.load();</script>
<p>
上讨论, 或者帮我在github上再加颗星
</p>
<a aria-label="Star jcouyang/ru on GitHub" data-count-aria-label="# stargazers on GitHub" data-count-api="/repos/jcouyang/ru#stargazers_count" data-count-href="/jcouyang/ru/stargazers" data-style="mega" data-icon="octicon-star" href="https://github.com/jcouyang/ru" class="github-button">Star</a><script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
<p>
也是极好的.
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p>Author: Jichao Ouyang</p>
<p>Modified: 2015-08-14 Fri 13:30</p>
<p><a href="https://travis-ci.org/jcouyang/blog"><img src="https://travis-ci.org/jcouyang/blog.svg?branch=master"></a> with <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.3.1)</p>
<p>&lt;&gt; with _(:з」∠)_ by <a href="https://github.com/jcouyang/orgpress">OrgPress</a></p>
<p><a href="/index.xml">RSS</a> | <a href="/archive.html">ARCHIVE</a> | <a href="/theindex.html">INDEX</a> | <a href="#" id="edit-in-github">EDIT</a></p>

<script>
 (function(){
   document.getElementById('edit-in-github').addEventListener("click",function(){
     var pathname = window.location.pathname;
     window.location.href = "https://github.com/jcouyang/blog/edit/master/org"+pathname.replace(".html",".org");
   })
 })()
</script>
<!-- Google Analystics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-32314154-10', 'auto');
  ga('send', 'pageview');

</script>
<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
 var disqus_shortname = 'orgblog';
 var href = window.location.href;
 href.replace(/^https/, 'http');
 var disqus_url = href;
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<!-- Swiftype Search -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

  _st('install','eGLqWnAM75a66SiXKVW3');
</script>
</div>
</body>
</html>
